# C++面向对象高级开发

## reference

```C++
int x = 0;
int *p = &x;
int &r = x; // r 代表 x。现在 r，x 都是0
int x2 = 5;
r = x2; // r 不能重新代表其他物体，现在，r，x 都是 5
int & r2 = r; // 现在 r2 是 5（r2 代表 r,亦相当于代表 x)
// 注意
// sizeof(r) == sizeof(x)
// &x == &r;
```

![](./img/reference.png)

实现上引用使用指针实现，逻辑上

object 和其 reference 的大小相同，地址也相同（全都是假象）

指针的大小为 4 字节（ 32 位），引用的大小和其代表的变量相同

指针可以改变，引用不能改变

```C++
typedef struct Stag{int a, b, c, d;} S;
int main()
{
    double x = 0;
    double* p = & x; // p 指向x，p 的值是x的地址
    double& r = x; // r 代表 x，现在 r，x 都是 0
    
    cout << sizeof(x) << endl; // 8
    cout << sizeof(p) << endl; // 4
    cout << sizeof(r) << endl; // 8
    cout << p << endl; // 0065FDFC
    cout << *p << endl; // 0
    cout << x << endl; // 0
    cout << r << endl; // 0
    cout << &x << endl; // 0065FDFC
    cout << &r << endl; // 0065FDFC
    
    S s;
    S& rs = s;
    cout << sizeof(s) << endl; // 16
    cout << sizeof(rs) << endl; // 16
    cout << &s << endl; // 0065FDE8
    cout << &rs << endl; // 0065FDE8
}
```

### reference 的常见用途

```C++
void func1(Cls* pobj) {pobj->xxx();} // pass by pointer
void func2(Cls obj) {obj.xxx();} // pass by value,reference
void func3(Cls& obj) {obj.xxx();} // 被调用端写法相同
......
Cls obj;
func1(&obj); // 接口不同
func2(obj); //调用端接口相同
func3(obj);
```

reference 通常不用于声明变量，而用于参数类型和返回类型的描述

same signature

```C++
double imag(const double& im) {......}
double imag(const double  im) {......} // Ambiguity
// 被视为 same signature，因此不能同时存在。
```

> const 是不是函数签名的一部分？是。
> ```C++
> double imag()const {}
> double imag(){}
> // 可以并存
> ```

## 对象模型：关于 vptr 和 vtbl

```C++
class A
{
public:
    virtual void vfunc1();
    virtual void vfunc2();
    void func1();
    void func2();
private:
    int m_data1, m_data2;
};

class B:public A
{
public:
	virtual void vfunc1();
	void func2();
private:
	int m_data3;
};

class C:public B
{
public:
	virtual void vfunc1();
	void func2();
private:
	int m_data1, m_data4;
}
```

![](./img/vptr.jpg)

当类中有虚函数时，对象中会多一个虚指针，指向虚表，大小会比数据相加多 4。虚表中存放虚函数的地址。虚表中存放地址的顺序为类中声明函数的顺序。

继承会把数据和函数都继承下来，继承函数是继承的函数的调用权。

A：两个虚函数和两个普通函数

B：继承了两个虚函数，其中改写 vfunc1()，func2() 与父类的 func2() 同名，但不是一个函数。

C：继承B的两个虚函数，改写其中的 vfunc1()，func2() 与父类函数同名但不是一个函数。

因此共有 4 个非虚函数和 4 个虚函数。

例：

A 父类，形状。子类代表各种形状如矩形、正方形、圆形。父类中定义虚函数 draw()，子类对其进行各自不同的实现。

使一个容器可以容纳各式各样的形状，由于不同的对象所占内存大小不同，可以使用指针实现，且指针一定要指向父类，之后可以指向各种子类。`list<A*> myLst;`

将形状的指针放进容器，在需要将形状画出来时，遍历容器中的指针，调用其各自的 draw() 函数。

### 静态和动态绑定

C++ 编译器看到一个函数会考虑将它静态绑定还是动态绑定。

静态绑定：CALL XXX (地址)

调用的地址是确定的。

符合以下条件会做动态绑定：

- 通过指针调用
- 指针向上转型（例如，指针指向一只猪，指针的类型为动物）
- 调用虚函数

这样编译器就会将程序编译成类似 `(*p->vptr[n])(p)` （表示通过指针访问类的虚函数）的形式。此时调用的函数是不确定的，调用哪一个函数由 p 决定，因此称为动态绑定。。

虚机制实现**多态**

