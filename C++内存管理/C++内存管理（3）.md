# C++内存管理

## 第三讲 malloc/free

### VC6 内存分配

```C++
// call stack	
		ExitProcess(code)
        _initterm(,,) // do terminators
            __endstdio(void)
        _initterm(,,) // do pre-terminators
      doexit(code, 0, 0)
    exit(code) // 9
    main() // 8
      _initterm(,,) // do c++ initializations
        __initstdio(void)
      _initterm(,,) // do initialization
    _cinit() // do C data initialize // 7
    _setenvp() // 6
    _setargv() // 5
    __crtGetEnvironmentStringsA() // 4
    GetCommandLineA() // 3
              __sbh_alloc_new_group(...)
              __sbh_alloc_new_region()
              __sbh_alloc_block(...) // SBH: Small Block Heap
            _heap_alloc_base(...)
          __heap_alloc_dbg(...)
        _nh_malloc_dbg(...)
      _malloc_dbg(...)
    _ioinit() // initialize lowio // 2
      __sbh_heap_init()
    _heap_init(...) // 1
    mainCRTStartup()
    KERNEL32! bff8b6e6()
  KERNEL32! bff8b598()
KERNEL32! bff89f5b()
```

```C++
// _heap_alloc_base(...)
if (size <= __sbh_threshold) // 3F8, i.e. 1016 
{
    pvReturn = _sbh_alloc_block(size); 
    // 如果比门限小，则通过该函数获取内存，为小区块服务
    if(pvReturn) return pvReturn;
}
if(size == 0) size = 1;
size = (size + ...)&~(...);
return HeapAlloc(_crtheap,0,size); // windows 函数
```

### VC10 内存分配

```C++
// call stack	
		ExitProcess(code)
        _initterm(,,) // do terminators
            __endstdio(void)
        _initterm(,,) // do pre-terminators
      doexit(code, 0, 0)
    exit(code) // 9
    main() // 8
      _initterm(,,) // do c++ initializations
        __initstdio(void)
      _initterm(,,) // do initialization
    _cinit() // do C data initialize // 7
    _setenvp() // 6
    _setargv() // 5
    __crtGetEnvironmentStringsA() // 4
    GetCommandLineA() // 3
              //__sbh_alloc_new_group(...)
              //__sbh_alloc_new_region()
              //__sbh_alloc_block(...) // SBH: Small Block Heap
            _heap_alloc_base(...)
          //__heap_alloc_dbg(...)
        _nh_malloc_dbg(...)
      _malloc_dbg(...)
    _ioinit() // initialize lowio // 2
      //__sbh_heap_init()
    _heap_init(...) // 1
    mainCRTStartup()
    KERNEL32! bff8b6e6()
  KERNEL32! bff8b598()
KERNEL32! bff89f5b()
```

```C++
// _heap_alloc_base(...)
#ifdef _DEBUG
#define _heap_alloc _heap_alloc_base
#endif 
//......
__forceinline void* __cdecl _heap_alloc (size_t size)
{
    if (_ctrheap == 0)
    {
        __FF_MSGBANNER(); /* write run-time error banner*/
        _NMSG_WRITE(_RT_CRT_NOTINIT); /* write message*/
        __crtExitProcess(255); /* normolly _exit(255)*/
    }
    return HeapAlloc(_crtheap, 0, size? size : 1); 
    // 无论什么大小都调用系统函数来分配内存
}
```

### SBH 之始——\_heap\_init() 和 \_\_sbh\_heap\_init()

```C++
int __cdecl _heap_init( int mtflag)
{
    // Initialize the "big-block" heap first.
    if ((_crtheap = HeapCreate(mtflag? 0:HEAP_NP_SERIALIZE, BYTES_PER_PAGE, 0))==NULL) // BYTES_PER_PAGE = 4096
        return 0;
    // Initialize the small-block heap
    if(__sbh_heap_init()==0)
    {
        HeapDestroy(_crtheap);
        return 0;
    }
    return 1;
}
// 不论 big-block heap 还是 small-block heap，只要失败就 return 0

//=========
int __cdecl __sbh_heap_init(void)
{
    if(!(__sbh_pHeaderList = HeapAlloc(_crtheap,0,16*sizeof(HEADER))))
        // HeapAlloc 的到的结果为指向 16 个 header 的头的指针
        return FALSE;
    __sbh_pHeaderScan = __sbh_pHeaderList;
    __sbh_pHeaderDefer = NULL;
    __sbh_cntHeaderList = 0;
    __sbh_sizeHeaderList = 16;
    
    return TRUE;
}
```

CRT 会先为自己建立一个 \_crtheap，然后从中配置 SBH 所需的 headers， regions 作为管理值用。App. 动态配置时若 size > threadhold 就以 HeapAlloc() 从 \_crtheap 取。若 size <= threadhold 就从 SBH 取（实际区块来自 VirtualAlloc()）

#### Header

```C++
typedef unsigned int BITVEC;
typedef struct tagHeader
{
    BITVEC bitEntryHi;
    BITVEC bitEntryLo;
    BITVEC bitCommit;
    void* pHeapData;
    struct tagRegion* pRegion;
}
HEADER, *PHEADER;
```

