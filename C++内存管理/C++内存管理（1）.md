# C++内存管理

## 第一讲 primitives

|分配|释放|类属|可否重载|
|--|--|--|--|
|malloc()|free()|c函数|不可|
|new|delete|C++表达式（expressions）|不可|
|::operator new()|::operator delete()|C++函数|可|
|allocator<T>::allocate()|allocate<T>::deallocate()|C++标准库|可自由设计并以之搭配任何容器|

```C++
// 以上四种方式的使用
void* p1 = malloc(512); // 512bytes
free(p1);

complex<int>* p2 = new complex<int>; // one object
delete p2;

void* p3 = ::operator new(512); // 512bytes
::operator delete(p3);

// 以下使用 C++ 标准库提供的 allocators.
// 其接口拥有标准规格，但实现厂商并未完全遵守：下面三者形式略异。
// 对于不同的编译器
#ifdef _MSC_VER
// 以下两个函数都是 non-static，一定要通过 object 调用。以下分配 3 个 this
	int* p4 = allocator<int>().allocate(3, (int*)0); //（int*)0 无用
	allocator<int>().deallocate(p4,3);
#endif
#ifdef __BORLANDC__
// 以下两个函数都是 non-static，一定要通过 object 调用。以下分配 5 个 this
	int* p4 = allocator<int>().allocate(5);
	allocator<int>().deallocate(p4,5);
	// 使用分配器在归还时需要写出分配的个数
#endif
#ifdef __GNUC__ // 早期版本
//以下两个函数都是 static。以下分配 512bytes。
	void* p4 = alloc:allocate(512);
	alloc::deallocate(p4, 512);
#endif
//==============
#ifdef __GNUC__ // gnuc 4.9
// 以下两个函数都是 non-static，一定要通过 object 调用。以下分配 7 个 this
	void* p4 = allocator<int>().allocate(7);
    allocator<int>().deallocate((int*)p4, 7);
// 以下两个函数都是 non-static，一定要通过 object 调用。以下分配 9 个 this
	void* p5 = __gnu_cxx::__pool_alloc<int>().allocate(9);
	__gnu_cxx::__pool_alloc<int>().deallocate((int*)p5, 9);
#endif


```

### new expression

`Complex* pc = new Complex(1,2);`

编译器转为

```C++
Complex *pc;
try
{
    void* mem = operator new(sizeof(Complex)); // allocation
    pc = static_cast<Complex*>(mem); // cast 指针转型
    pc->Complex::Complex(1,2); // constructor
    // 注意，只有编译器才可以像上面那样直接呼叫 ctor
    // 欲直接调用 ctor，可运用 placement new
    // new(p)Complex(1,2);
}
catch(std::bad_alloc)
{
    // 若 allocation 失败就不执行 constructor
}

// vc98 runtime labrary
void* operator new(size_t size, const std::nothrow_t&)_THROW0()
{
    // try to allocate size bytes
    void *p;
    while ((p=malloc(size))==0)
    {
        // buy more memory or return null pointer
        _TRY_BEGIN
            if(_callnewh(size)==0) break; // call new handler可以自己设置的函数
        _CATCH(std::bad_alloc) return(0);
        _CATCH_END
    }
}
// std::nothrow_t&
// the struct is used as a function parameter to operator new to 
// indicate that the function should return a null pointer to report 
// an allocation failure, rather than throw an exception
```

### delete expression

```C++
Complex* pc = new Complex(1,2);
...
delete pc;
// 编译器转为
pc->~Complex(); // 先析构
operator delete(pc); // 然后释放内存
// ...\vc98\crt\stc\delop.cpp
void __cdecl operator delete(void *p)_THROW0()
{// free an allcated object
    free(p); 
}
```

### Ctor&Dtor 直接调用

```C++

string* pstr = new string;
cout << "str=" << *pstr << endl;
//  pstr->string::string("test");
		// [Error] 'class str::basic_string<char>' has no member named 'string'
//  pstr->~string(); // crash
cout << "str= " << *pstr << endl;
// 不能直接调用构造函数，但是可以直接调用析构函数，但是构造函数调用不成功直接调用析构函数也会导致崩溃

class A
{
    public:
    int id;
    A(int i):id(i) {cout << "ctor. this=" << this << " id=" << id << endl;}
    ~A() {cout << "dtor. this=" << this << endl; }
}


A* pa = new A(1); // ctor. this=000307A8 id = 1
cout << pa->id << endl; // 1
// pA->A::A(3) // in VC6: ctor. this=000307A8 id = 3
			   // in GCC:[Error] cannot call constuctor 'jj02::A::A'directly
// A::A(5); // in VC6 :ctor. this=0013FF60 id = 6
            //         dtor. this=0013FF70
            // in GCC:[Error] cannot call constructor 'jj02::A::A' directly
            // [note] for a functoin-style cast, remove the redundant '::A'
cout << pA->id<< endl; // in VC6:3 in GCC: 1
delete pA; // dtor. this= 000307A8
```

### array new, array delete

```C++
Complex* pca = new Complex;
// 唤起3次默认ctor
// 无法由参数给予赋值
// 因此必须有默认ctor
......
delete[] pca; // 唤起3次dtor
string* psa = new string[3];
......
delete psa; // 唤起1次 dtor
```

如果没有对每个 object 调用 dtor，对 class without ptr member 可能没有影响，但是对 class with pointer member 通常有影响。

如果使用 array new 而不使用 array delete，会导致内存泄漏：3个指针指向 3 个 object，而 3 个 object 没有被全部销毁

```C++
class A
{
    public:
    int id;
    A():id(0){cout << "default ctor.this="<<this<<"id="<<id<<endl;}
    A(int i):id(i){cout<<"ctor .this="<<this<<"id="<<id<<endl;}
    ~A(){cout<<"dtor.this="<<this<<"id="<<id<<endl;}
};
//================
A* buf = newA[size]; // default ctor 3 次，[0]先于[1]先于[2]
// A 必须有 default ctor，
// 否则 [Error] no matching function for call to 'A::A()'
A* tmp = buf;
cout << "buf="<<buf<<" tmp="<<tmp<<endl;
for(int i = 0; i < size；++i) // 设初值
{
    new (tmp++)A(i); // ctor 3次
}
cout << "buf="<<buf<<" tmp="<<tmp<<endl;
delete[] buf; // dtor 3 次，次序逆反，[2]先于[1]先于[0]
//======output===========
/*
default ctor. this=0x3e398c id = 0
default cotr. this=0x3e3990 id = 0
default ctor. this=0x3e3994 id = 0
buf=0x3e398c tmp=0x3e398c
ctor. this=0x3e398c id = 0
ctor. this=0x3e3990 id = 1
ctor. this=0x3e3994 id = 2
buf=0x3e398c tmp=0x3e3998
dtor. this=0x3e3994 id=2
dtor. this=0x3e3990 id=1
dtor. this=0x3e398c id=0
*/
```

#### 

### placement new

placement new 允许我们将 object 构建于 allocated memory 中。

没有所谓的 placement delete，因为 placement new 根本没分配 memory，亦或称呼与 placement new 对应的 operator delete 为 placement delete。

```C++
#include <new>
char* buf = new char[sizeof(Complex) * 3];
Complex* pc = new(buf)Complex(1,2);
......
delete[] buf; 
// Complex* pc = new(buf)Complex(1,2);编译器转为
Complex *pc;
try{
    void* mem = operator new(sizeof(Complex),buf); // allocate
    // void* operator new(size_t, void* loc)
    // {return loc;}
    pc = static_cast<Complex*>(mem); // cast
    pc->Complex::Complex(1,2); // consruct
}
catch(std::bad_alloc)
{
    // 若 alloc 失败就不执行 constructor
}
```

placement new 等同于调用 ctor

注意：关于 placement new 或指 new(p) 或指::operator new(size, void*)

