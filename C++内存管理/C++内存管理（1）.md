# C++内存管理

## 第一讲 primitives

|分配|释放|类属|可否重载|
|--|--|--|--|
|malloc()|free()|c函数|不可|
|new|delete|C++表达式（expressions）|不可|
|::operator new()|::operator delete()|C++函数|可|
|allocator<T>::allocate()|allocate<T>::deallocate()|C++标准库|可自由设计并以之搭配任何容器|

```C++
// 以上四种方式的使用
void* p1 = malloc(512); // 512bytes
free(p1);

complex<int>* p2 = new complex<int>; // one object
delete p2;

void* p3 = ::operator new(512); // 512bytes
::operator delete(p3);

// 以下使用 C++ 标准库提供的 allocators.
// 其接口拥有标准规格，但实现厂商并未完全遵守：下面三者形式略异。
// 对于不同的编译器
#ifdef _MSC_VER
// 以下两个函数都是 non-static，一定要通过 object 调用。以下分配 3 个 this
	int* p4 = allocator<int>().allocate(3, (int*)0); //（int*)0 无用
	allocator<int>().deallocate(p4,3);
#endif
#ifdef __BORLANDC__
// 以下两个函数都是 non-static，一定要通过 object 调用。以下分配 5 个 this
	int* p4 = allocator<int>().allocate(5);
	allocator<int>().deallocate(p4,5);
	// 使用分配器在归还时需要写出分配的个数
#endif
#ifdef __GNUC__ // 早期版本
//以下两个函数都是 static。以下分配 512bytes。
	void* p4 = alloc:allocate(512);
	alloc::deallocate(p4, 512);
#endif
//==============
#ifdef __GNUC__ // gnuc 4.9
// 以下两个函数都是 non-static，一定要通过 object 调用。以下分配 7 个 this
	void* p4 = allocator<int>().allocate(7);
    allocator<int>().deallocate((int*)p4, 7);
// 以下两个函数都是 non-static，一定要通过 object 调用。以下分配 9 个 this
	void* p5 = __gnu_cxx::__pool_alloc<int>().allocate(9);
	__gnu_cxx::__pool_alloc<int>().deallocate((int*)p5, 9);
#endif


```

### new expression

`Complex* pc = new Complex(1,2);`

编译器转为

```C++
Complex *pc;
try
{
    void* mem = operator new(sizeof(Complex)); // allocation
    pc = static_cast<Complex*>(mem); // cast 指针转型
    pc->Complex::Complex(1,2); // constructor
    // 注意，只有编译器才可以像上面那样直接呼叫 ctor
    // 欲直接调用 ctor，可运用 placement new
    // new(p)Complex(1,2);
}
catch(std::bad_alloc)
{
    // 若 allocation 失败就不执行 constructor
}

// vc98 runtime labrary
void* operator new(size_t size, const std::nothrow_t&)_THROW0()
{
    // try to allocate size bytes
    void *p;
    while ((p=malloc(size))==0)
    {
        // buy more memory or return null pointer
        _TRY_BEGIN
            if(_callnewh(size)==0) break; // call new handler可以自己设置的函数
        _CATCH(std::bad_alloc) return(0);
        _CATCH_END
    }
}
// std::nothrow_t&
// the struct is used as a function parameter to operator new to 
// indicate that the function should return a null pointer to report 
// an allocation failure, rather than throw an exception
```

### delete expression

```C++
Complex* pc = new Complex(1,2);
...
delete pc;
// 编译器转为
pc->~Complex(); // 先析构
operator delete(pc); // 然后释放内存
// ...\vc98\crt\stc\delop.cpp
void __cdecl operator delete(void *p)_THROW0()
{// free an allcated object
    free(p); 
}
```

### Ctor&Dtor 直接调用

```C++

string* pstr = new string;
cout << "str=" << *pstr << endl;
//  pstr->string::string("test");
		// [Error] 'class str::basic_string<char>' has no member named 'string'
//  pstr->~string(); // crash
cout << "str= " << *pstr << endl;
// 不能直接调用构造函数，但是可以直接调用析构函数，但是构造函数调用不成功直接调用析构函数也会导致崩溃

class A
{
    public:
    int id;
    A(int i):id(i) {cout << "ctor. this=" << this << " id=" << id << endl;}
    ~A() {cout << "dtor. this=" << this << endl; }
}


A* pa = new A(1); // ctor. this=000307A8 id = 1
cout << pa->id << endl; // 1
// pA->A::A(3) // in VC6: ctor. this=000307A8 id = 3
			   // in GCC:[Error] cannot call constuctor 'jj02::A::A'directly
// A::A(5); // in VC6 :ctor. this=0013FF60 id = 6
            //         dtor. this=0013FF70
            // in GCC:[Error] cannot call constructor 'jj02::A::A' directly
            // [note] for a functoin-style cast, remove the redundant '::A'
cout << pA->id<< endl; // in VC6:3 in GCC: 1
delete pA; // dtor. this= 000307A8
```

