# 拷贝控制

## 拷贝、赋值与销毁

### 拷贝构造函数

拷贝构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值。

拷贝初始化：

- 用=定义变量
- 将一个对象作为实参传递给一个非引用类型的形参
- 从一个返回类型为非引用类型的函数返回一个对象
- 用花括号列表初始化一个数组中的元素或者一个聚合类中的成员

指出下面程序片段中那些地方使用了拷贝构造函数：

```C++
Point global;
Point foo_bar(Point arg) // 传参调用一次拷贝构造函数
{
    Point local = arg, *heap = new Point(global);  // local, *heap各调用一次
    *heap = local; // 将local拷贝到heap指定的地址中
    Point pa[2] = {local, *heap}; // 花括号列表初始化一个数组中的元素，调用2次
    return *heap; // 返回类型为非引用类型的函数返回一个对象，调用一次
}
```

给定下面的类框架，编写一个拷贝构造函数，拷贝所有成员。构造函数应该动态分配一个新的string，并将对象拷贝到ps指向的位置，而不是拷贝ps本身。

```C++
class HasPtr
{
public:
    HasPtr(const std::string &s = std::string()):
    	ps(new std::string(s)), i(0) {}
private:
    std::string *ps;
    int i;
};
HasPtr::HasPtr(const HasPtr& hp)
{
    ps = new strint(*hp.ps);
    i = 0;
}
```

### 拷贝赋值运算符

拷贝赋值运算符接受一个与其所在类相同类型的参数

```C++
class Foo
{
public:
    Foo& operator=(const Foo&); // 赋值运算符
    // ...
}
```

为HasPtr编写赋值运算符

```C++
class HasPtr
{
public:
    HasPtr(const std::string &s = std::string()):
    	ps(new std::string(s)), i(0) {}
    HasPtr& operator=(const HasPtr& pra);
private:
    std::string *ps;
    int i;
};

HasPtr& HasPtr::operator=(const HasPtr& rhs)
{
    auto newps = nwe string(*rhs.ps); // 拷贝指向指针的对象
    delete ps; // 销毁原string
    ps = newps; // 指向新string
    i = rhs.i; // 使用内置的int赋值
    return *this; // 返回一个此时对象的引用
}
```

### 析构函数

析构函数释放对象使用的资源，并销毁对象的非static数据成员。析构函数不接受参数，因此不能被重载。

在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化顺序的逆序销毁。

```C++
class foo
{
public:
    ~Foo(); // 析构函数
    // ...
};
```

析构函数中，析构部分是隐式的。销毁类类型的成员需要执行成员自己的析构函数。内置类型没有析构函数，因此销毁内置类型成员什么也不需要做。

调用析构函数：当一个对象被销毁时就会调用析构函数，包括

- 变量在其离开作用域时被销毁
- 当一个对象被销毁时，其成员被销毁
- 容器（无论是标准库容器还是数组）被销毁时，其元素被销毁
- 对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁
- 对于临时对象，当创建它的完整表达式结束时被销毁。

当指向一个对象的引用或指针离开作用域时，析构函数不会执行。

为HasPtr定义一个析构函数

```C++
HasPtr::~HasPtr()
{
    delete ps;
}
```

下面的代码会调用几次析构函数？

```C++
bool fcn(const Sales_data *trans, Sales_data accum)
{
    Sales_data item1(*trans), item2(accum);
    return item1.isbn() != item2.isbn(); 
    // 函数结束时，item1和item2的生命期结束，调用两次析构函数
    // 参数 accum的生命期结束，被销毁，调用一次析构函数
    // 由于 trans为Sales_data的指针，因此不会被销毁。
}
```

```C++

#include <iostream>
#include <vector>
using namespace std;
struct X
{
    X(){cout << "X()" << endl;}
    X(const X&) {cout << "X(const X&)" << endl;}
    X& operator= (const X& rhs) {cout << "=(const X&)" << endl; return *this;}
    ~X(){ cout << "~X()" << endl;}
};

void f1(X x){}
void f2(X &x){}

int main(int argc, char **argv)
{
    cout << "local:" << endl;
    X x;
    cout << endl;

    cout << "pass by value" << endl;
    f1(x);
    cout << endl;

    cout << "pass by ref" << endl;
    f2(x);
    cout << endl;

    cout << "new" << endl;
    X *px = new X;
    cout << endl;

    cout << "put in to vector" << endl;
    vector<X> vx;
    vx.push_back(x);
    cout << endl;

    cout << "delete" << endl;
    delete px;
    cout << endl;

    cout << "init & assignment" << endl;
    X y = x;
    y = x;
    cout << endl;

    cout << "end" << endl;
    return 0;
}
// output
/*
local:
X()

pass by value
X(const X&)
~X()

pass by ref

new
X()

put in to vector
X(const X&)

delete
~X()

init & assignment
X(const X&)
=(const X&)

end
~X() // 析构y
~X() // 析构vector<X> vx中的元素
~X() // 析构x
*/
```

### 三/五法则

有三个基本操作可以控制类的拷贝操作：拷贝构造函数、拷贝赋值运算符和析构函数。

新标准下一个类还可以定义一个移动构造函数和一个移动赋值运算符。

**需要析构函数的类也需要拷贝和赋值操作**

例如包含指针的类，需要对指针动态分配内存。如果使用编译器定义的合成拷贝构造函数，那么所有的指针可能都会指向相同的内存，再析构其中某一个对象时，其他对象中指针指向的内容也会被销毁。

**需要拷贝操作的类也需要赋值操作，反之亦然**

例如一个类为每个对象分配一个独有的、唯一的序号。这个类的拷贝构造函数会为每个对象分配一个唯一的序号。此外，这个类还需要自定义拷贝赋值运算符来避免序号赋予目的对象。但是这个类不需要析构函数。

假设有一个numbered类，有一个默认的构造函数，能为每个对象生成唯一的序号，保存在mysn的数据成员中。

定义如下函数，则下面的代码会输出什么内容？

```C++
void f(numbered s) {cout << s.mysn << endl;}
numbered a, b = a, c = b;
f(a); f(b); f(c);
```

- 如果numbered使用合成的拷贝构造函数，则abc的序号相同，因为合成拷贝构造函数为浅拷贝
- 如果numbered定义了一个能生成新序号的拷贝构造函数，则输出为3 4 5，因为a, b, c在定义时，序号为0，1，2，而调用函数f时，会再次调用拷贝构造函数，因此需要变为3，4，5。
- 如果函数参数修改为`numbered& s`，则调用函数是不会调用拷贝构造函数，输出为0，1，2。

### 使用=default

通过将拷贝控制成员定义为=default来显式地要求编译器生成合成地版本。例如：

```C++
class Sales_data
{
public:
    // 拷贝控制成员;使用default
    Sales_data() = default;
    Sales_data(const Sales_data&) = default;
    Sales_data& operator=(const Sales_data &);
    ~Sales_data() = default;
    // 其他成员地定义
};
Sales_data& Sales_data::operator=(const Sales_data) = default;
```

在类内使用default时，合成地函数隐式地声明为内联地。如果不希望它是内联函数，则需要在类外进行定义使用default。只能对具有合成版本的成员函数使用default。

### 阻止拷贝

新标准中，可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数，以阻止拷贝和赋值。删除函数虽然被定义，但是不能以任何方式使用它们。

```C++
struct NoCopy
{
    NoCopy() = default; // 使用合成的默认构造函数
    NoCopy(const NoCopy&) = delete; // 阻止拷贝；
    NoCopy& operator=(const NoCopy&) = delete; // 阻止赋值
    ~NoCopy() = default; // 使用合成的析构函数
    // 其他成员
}
```

=delete必须出现在函数第一次声明的时候。

析构函数不能是删除的。对于一个删除析构函数的类，可以动态分配这种类型的对象但是不能释放它们。

对于某些类，合成的拷贝控制成员可能是删除的：

- 如果类的某个成员的析构函数是删除的或不可访问的（如private），则类的析构函数被定义为删除的
- 如果类的某个成员的拷贝构造函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的。如果类的某个成员的析构函数是删除的或不可访问的，则类合成的拷贝构造函数也被定义为删除的。
- 如果类的某个成员的拷贝复制运算符是删除的或不可访问的，或是类有一个const的或引用成员，则类的合成拷贝复制运算符被定义为删除的
- 如果类的某个成员的析构函数是删除的或不可访问的，或是类有一个引用成员，它没有类内初始化器，或是类有一个const成员，它没有类内初始化器且基本类型未显式定义默认构造函数，则该类的默认构造函数被定义为删除的。

即，如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。

## 拷贝控制和资源管理

### 行为象值的类

拷贝一个像值的对象时，副本和原对象时完全独立的。改变副本不会对原对象有任何影响。

以HasPtr为例

```C++
class HasPtr
{
public:
    HasPtr(const std::string &s = std::string()):ps(new std::string(s)), i(0) {}
    HasPtr(const HasPtr &p):ps(new std::string(*p.ps)), i(p.i){}
    HasPtr& operator = (const HasPtr&);
    ~HasPtr() {delete ps};
private:
    std::string *ps;
    int i;
};
HasPtr& HasPtr::operator=(const HasPtr& rhs)
{
    auto newp = new string(*rhs.ps); // 拷贝底层string
    delete ps; // 释放旧内存
    ps = newp;
    i = rhs.i;
    return *this;
}
// 要先拷贝底层的string再释放旧内存。
// 因为如果需要拷贝的string和ps指向的时同一块内存，
// 先释放旧内存就会将要拷贝的内容一起释放。
```

### 行为像指针的类

行为像指针的类共享状态，当我们拷贝一个这种类的对象时，副本和原对象使用相同的数据，改变副本也会改变原数据。

引用计数：

- 除了初始化对象外，每个构造函数还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态。当我们创建一个对象时，只有一个对象共享状态，因此计数器初始化为1。
- 拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器，拷贝构造函数递增共享的计数器。指出给定对象的状态又被一个新用户所共享。
- 析构函数递减计数器，指出共享状态的用户又少了一个。如果 计数器变为0，则析构函数释放状态。
- 拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。如果左侧运算对象的计数器变为0，则销毁状态。

通过引用计数，可以编写类指针的HasPtr

```C++
class HasPtr
{
public:
    // 构造函数分配新的string和新的计数器，将计数器置为1
    HasPtr(const std::string&s = std::string()):
        ps(new std::string(s)), i(0), use(new std::size_t(1)){}
    // 拷贝构造函数拷贝所有三个数据成员，并递增计数器
    HasPtr(cost HasPtr &p):
    	ps(p.ps), i(p.i), use(p.use) {++*use;}
    HasPtr& operator=(const HasPtr&);
    ~HasPtr();
private:
    std::string *ps;
    int i;
    std::size_t *use; //用来记录有多少个共享*ps的成员
};
HasPtr::~HasPtr()
{
    if (--*use == 0)
    {
        delete ps;
        delete use;
    }
}
HasPtr& HasPtr::operator=(const HasPtr& rhs)
{
    ++*rhs.use;
    if(--*use == 0)
    {
        delete ps;
        delete use;
    }
    ps = rhs.ps;
    i = rhs.i;
    use = rhs.use;
    return *this;
}
```

## 交换操作

为类值的HasPtr定义一个swap函数

```C++
class HasPtr
{
    //...
    friend void swap(HasPtr& , HasPtr&);
    //...
};
inline void swap(HasPtr& lhs, HasPtr& rhs)
{
    using std::swap;
    swap(lhs.ps, rhs.ps);
    swap(lhs.i, rhs.i);
}
```

注意这里使用的是swap而不是std::swap。标准库中的swap对HasPtr中的string会进行不必要的拷贝。每个swap调用都应该是未加限定的。 

### 在赋值运算符中使用swap

```C++
// rhs按值传递，意味着HasPtr的拷贝构造函数将右侧运算对象中的string拷贝到rhs
HasPtr& HasPtr::operator = (HasPtr rhs)
{
    // 交换左侧对象和局部变量rhs的内容
    swap(*this, rhs); // rhs现在指向本对象曾经使用的内存
    return *this; // rhs被销毁，从而delete了rhs中的指针
}
```

这种方法自动处理了自赋值情况且天然就是异常安全的。