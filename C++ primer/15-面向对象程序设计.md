# 面向对象程序设计

## OOP：概述

OOP的核心思想是数据抽象、继承和动态绑定

```C++
class Quote
{
public:
    std::string isbn() const;
    viretual double net_price(std::size_t n) const;
};
class Bulk_quote : public Quote // Bulk_quote继承了Quote
{
public:
	double net_price(std::size_t) const override;
};
// 动态绑定
// 通过动态绑定，可以使用它同一段代码分别处理Quote和Bulk_quote的对象
double print_total(ostream & os, const Quote &item, size_t n)
{
    double ret = item.net_price(n);
    os << "ISBN: " << item.isbn()  // 调用Quote.isbn()
        << " # sold: " << n << " totla due: " << ret << endl;
    return ret;
}
// basic 的类型是 Quote, bukl的类型是 Bulk_quote
print_total(cout, basic, 20); //调用Quote的net_price
print_total(cout, bulk, 20); // 调用Bukl_quote的net_price
```

## 定义基类和派生类

```C++
class Quote
{
public:
    Quote() = default;
    Quote(const std::string &book, double sales_price):
    	bookNo(book), price(sales_price){ }
    std::string isbn() const {return bookNo;}
    viretual double net_price(std::size_t n) const
    { 
        return n * price;
    }
    virtual ~Quote() = default; // 对析构函数进行动态绑定
private:
    std::string bookNo;
protected:
    double price = 0.0; // 希望派生类能够访问而其他用户不可以，使用protected
};
class Bulk_quote : public Quote // Bulk_quote继承了Quote
{
public:
    Bulk_quote()= default;
    Bulk_quote(const std::string&, double, std::size_t, double);
	double net_price(std::size_t) const override;
private:
    std::size_t min_qty = 0; // 适用折扣政策的最低购买数量
    double discount = 0.0; // 以小数表示的折扣额
};
```

#### 派生类中的虚函数

C++11新标准允许派生类显式地著名它使用某个成员函数覆盖了它继承的虚函数，具体做法是再形参列表后面，或者const成员函数的const后面，或者再引用成员函数的引用限定符后面添加关键字override。

#### 派生类对象及派生类向基类的类型转换

在一个对象中，继承自基类的部分和派生类自定义的部分不一定是连续存储的。

因为在派生类对象中含有与其基类对应的组成部分，所以我们能把派生类的对象当成基类对象来使用，而且也能将基类的指针或引用绑定到派生类对象中的基类部分上。

```C++
Quote item; //基类对象
Bulk_quote bulk; // 派生类对象
Quote *p = &item; // p指向Quote对象
p = &bulk; // p指向bulk的Quote部分
Quote &r = bulk; // r绑定到bulk的Quote部分
```

这种转换通常称为派生到基类的类型转换。编译器会隐式地执行派生类到基类的转换。我们可以把派生类对象或者派生类对象的引用用在需要基类引用的地方，也可以把派生类对象的指针用在需要基类指针的地方。

## 虚函数

## 抽象函数

## 访问控制与继承

## 继承中的类作用域

## 构造函数与拷贝控制

## 容器与继承